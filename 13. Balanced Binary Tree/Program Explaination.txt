
âœ… Leetcode 110: Balanced Binary Tree (Java Solution â€” O(n) Time Complexity)

ğŸ”§ Optimal Java Code (Bottom-Up DFS):

public class Solution {
    public boolean isBalanced(TreeNode root) {
        return checkHeight(root) != -1;
    }

    private int checkHeight(TreeNode node) {
        if (node == null) return 0;

        int left = checkHeight(node.left);
        if (left == -1) return -1;

        int right = checkHeight(node.right);
        if (right == -1) return -1;

        if (Math.abs(left - right) > 1) return -1;

        return Math.max(left, right) + 1;
    }
}

ğŸ“ Explanation (Line-by-Line):

public boolean isBalanced(TreeNode root) {
    return checkHeight(root) != -1;
}
â¡ï¸ Agar checkHeight() -1 return karta hai, toh tree unbalanced hai. Warna balanced.

private int checkHeight(TreeNode node) {
    if (node == null) return 0;
}
â¡ï¸ Agar node null hai toh height 0 return karo (base case).

int left = checkHeight(node.left);
if (left == -1) return -1;
â¡ï¸ Left subtree ka height check karo. Agar left unbalanced hai (-1), toh tree bhi unbalanced hai â€” return -1.

int right = checkHeight(node.right);
if (right == -1) return -1;
â¡ï¸ Same logic right subtree ke liye bhi apply hota hai.

if (Math.abs(left - right) > 1) return -1;
â¡ï¸ Agar left aur right subtree ka height difference 1 se zyada ho, toh tree unbalanced hai.

return Math.max(left, right) + 1;
â¡ï¸ Agar balanced hai, toh current node ki height return karo.

ğŸ§  Time Complexity:
â¡ï¸ O(n) â€” Har node sirf ek baar visit hoti hai.

ğŸ§  Space Complexity:
â¡ï¸ O(h) â€” Recursive stack space (height of tree).

ğŸ”— If any need please ask me: https://www.linkedin.com/in/saurabh884095/
