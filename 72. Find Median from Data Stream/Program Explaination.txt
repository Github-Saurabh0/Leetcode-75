LeetCode 295 â€“ Find Median from Data Stream

class MedianFinder {
    private PriorityQueue<Integer> small; // Max Heap
    private PriorityQueue<Integer> large; // Min Heap

    public MedianFinder() {
        small = new PriorityQueue<>(Collections.reverseOrder());
        large = new PriorityQueue<>();
    }

    public void addNum(int num) {
        small.offer(num);
        large.offer(small.poll());

        if (small.size() < large.size()) {
            small.offer(large.poll());
        }
    }

    public double findMedian() {
        if (small.size() == large.size()) {
            return (small.peek() + large.peek()) / 2.0;
        }
        return small.peek();
    }
}

Explanation

PriorityQueue<Integer> small = MaxHeap (left side)
PriorityQueue<Integer> large = MinHeap (right side)
ðŸ”¹ small: lower half numbers
ðŸ”¹ large: upper half numbers

Constructor â†’ dono heaps initialize kiye.

addNum(int num)
ðŸ”¹ Step 1: num ko small (maxheap) me daala
ðŸ”¹ Step 2: small se top element large (minheap) me daala (to balance)
ðŸ”¹ Step 3: Agar large zyada bada ho gaya ho toh wapas small me daal do

â†’ Is logic se heaps ka balance maintained rahega

findMedian()
ðŸ”¹ Agar dono heaps ka size equal hai:
   return average of top elements
ðŸ”¹ Agar unequal:
   return top of small (kyunki vo zyada size ka hoga)
   
Example:
addNum(1)
addNum(2)
findMedian() â†’ 1.5

addNum(3)
findMedian() â†’ 2.0

Time and Space Complexity:
Operation	Time	Space
addNum()	O(log n)	O(n)
findMedian()	O(1)	O(n)

Efficient for dynamic data stream scenarios.

ðŸ”— Need more help or Java tricks?
https://www.linkedin.com/in/saurabh884095/