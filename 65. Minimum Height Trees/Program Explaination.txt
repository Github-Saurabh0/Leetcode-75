âœ… Java Code (Clean, Fast, Accurate Parsing)

class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if (n == 1) return Collections.singletonList(0);

        List<Set<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new HashSet<>());

        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        List<Integer> leaves = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (graph.get(i).size() == 1) leaves.add(i);
        }

        while (n > 2) {
            n -= leaves.size();
            List<Integer> newLeaves = new ArrayList<>();

            for (int leaf : leaves) {
                int neighbor = graph.get(leaf).iterator().next();
                graph.get(neighbor).remove(leaf);
                if (graph.get(neighbor).size() == 1) newLeaves.add(neighbor);
            }

            leaves = newLeaves;
        }

        return leaves;
    }
}


ğŸ“˜ Explanation

if (n == 1) return Collections.singletonList(0);
ğŸ”¹ Agar graph mein sirf 1 node hai, toh wahi root hoga â€” seedha return kar diya.

List<Set<Integer>> graph = new ArrayList<>();
ğŸ”¹ Graph ko adjacency list ke form mein represent kar rahe hain using Set (to handle bidirectional edges).

for (int i = 0; i < n; i++) graph.add(new HashSet<>());
ğŸ”¹ Har node ke liye ek empty set banaya (jisme neighbors store honge).

for (int[] edge : edges)
ğŸ”¹ Sab edges ko process karke graph build kiya (undirected graph hai).

List<Integer> leaves = new ArrayList<>();
ğŸ”¹ Leaves ka list banaya â€” jin nodes ki degree = 1 hai.

for (int i = 0; i < n; i++) { if (graph.get(i).size() == 1) leaves.add(i); }
ğŸ”¹ Sab leaves identify kar liye (start mein).

while (n > 2)
ğŸ”¹ Jab tak 2 ya usse kam nodes bache, tab tak loop chalega â€” kyunki 1 ya 2 nodes hi MHT ka root ban sakte hain.

n -= leaves.size();
ğŸ”¹ Har round mein jitne leaves hote hain, unhe hata kar node count update karte hain.

int neighbor = graph.get(leaf).iterator().next();
ğŸ”¹ Leaf ke connected neighbor ko nikaala.

graph.get(neighbor).remove(leaf);
ğŸ”¹ Us neighbor se leaf ko hata diya.

if (graph.get(neighbor).size() == 1) newLeaves.add(neighbor);
ğŸ”¹ Agar ab neighbor bhi leaf ban gaya ho, toh usse next round ke leaves mein daal diya.

leaves = newLeaves;
ğŸ”¹ Next round ke leaves set kar diye.

return leaves;
ğŸ”¹ Bache hue nodes hi root honge â€” unko return kar diya.

ğŸ§  Example:
Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: 1 is the only root that gives minimum height (1-level tree).

ğŸš€ Time & Space Complexity:
Time: O(n)
Space: O(n)

ğŸ”— Facing any issue or want more Java tricks?
Connect here â†’ https://www.linkedin.com/in/saurabh884095/