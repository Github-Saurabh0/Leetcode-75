âœ… Java Code (Best Optimized DP Approach)

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);  // Fast lookup ke liye set banaya
        boolean[] dp = new boolean[s.length() + 1];     // dp[i] = s.substring(0, i) tak break ho sakta hai ya nahi
        dp[0] = true;                                   // Empty string always break ho sakti hai

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                // Agar s[0...j] tak break ho sakta hai aur s[j...i] wordSet me hai
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true;   // s[0...i] tak break ho sakta hai
                    break;          // Ek valid break mil gaya, ab next i par jao
                }
            }
        }

        return dp[s.length()];  // pura string break ho paya ya nahi
    }
}


ðŸ“˜ Explanation (Line by Line)
Set<String> wordSet = new HashSet<>(wordDict);
ðŸ”¹ Word list ko fast lookup ke liye HashSet me convert kiya.

boolean[] dp = new boolean[s.length() + 1];
ðŸ”¹ dp[i] batata hai ki s[0...i) tak ka string valid hai ya nahi.

dp[0] = true;
ðŸ”¹ Empty string always valid hoti hai (base case).

ðŸ’¡ Loop Explanation:
for (int i = 1; i <= s.length(); i++):
ðŸ”¹ i tak ka substring check kar rahe hain.

for (int j = 0; j < i; j++):
ðŸ”¹ har point par string ko 2 parts me tod rahe hain: s[0...j] and s[j...i]

if (dp[j] && wordSet.contains(s.substring(j, i))):
ðŸ”¹ Agar pehla part already break ho gaya (dp[j] == true)
ðŸ”¹ aur second part wordDict me present hai
ðŸ”¹ toh dp[i] = true kar do

break;
ðŸ”¹ Jaisi hi ek valid break milti hai, loop chhod do (optimization)

ðŸš€ Time and Space Complexity
Time: O(nÂ²) â†’ nested loop for all substrings

Space: O(n + m) â†’ n = length of string, m = total length of dictionary

ðŸ”— If any need please ask me:
https://www.linkedin.com/in/saurabh884095/