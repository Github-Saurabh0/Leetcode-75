âœ… Leetcode 235: Lowest Common Ancestor of a Binary Search Tree (Java Solution â€” O(log n) Average Time)

ğŸ”§ Optimal Java Code:

public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (root != null) {
            if (p.val < root.val && q.val < root.val) {
                root = root.left;
            } else if (p.val > root.val && q.val > root.val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
    }
}

ğŸ“ Explanation (Line-by-Line):

while (root != null) {
â¡ï¸ Jab tak root null nahi hota, tab tak check karte jao.

if (p.val < root.val && q.val < root.val) {
â¡ï¸ Agar dono p aur q ka value current root se chhota hai,
â¡ï¸ toh LCA left subtree me hoga, left mein jao.

    root = root.left;

} else if (p.val > root.val && q.val > root.val) {
â¡ï¸ Agar dono p aur q ka value current root se bada hai,
â¡ï¸ toh LCA right subtree me hoga, right mein jao.

    root = root.right;

} else {
â¡ï¸ Ek chhota hai aur ek bada ya ek equal hai â€” yehi LCA hai.

    return root;
}

return null;
â¡ï¸ Safety ke liye agar kuch galat input ho toh.

ğŸ§  Time Complexity:
â¡ï¸ O(log n) â€” average case (balanced BST), O(n) worst case (unbalanced BST)

ğŸ§  Space Complexity:
â¡ï¸ O(1) â€” iterative solution, no extra space.

ğŸ”— If any need please ask me: https://www.linkedin.com/in/saurabh884095/