
âœ… Leetcode 226: Invert Binary Tree (Java Solution â€” 0.5ms to 1ms)

ğŸ”§ Optimal Java Code (Recursive):

public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        root.left = right;
        root.right = left;

        return root;
    }
}

ğŸ“ Explanation (Line-by-Line):

public TreeNode invertTree(TreeNode root) {
â¡ï¸ Function `invertTree` ek tree ka root node leta hai aur inverted tree return karta hai.

if (root == null) return null;
â¡ï¸ Base condition: agar root null hai toh wahi return karo â€” koi inversion karne ki zarurat nahi.

TreeNode left = invertTree(root.left);
â¡ï¸ Recursively left subtree ko invert karo aur result `left` mein store karo.

TreeNode right = invertTree(root.right);
â¡ï¸ Recursively right subtree ko invert karo aur result `right` mein store karo.

root.left = right;
root.right = left;
â¡ï¸ Ab dono subtrees swap kar do â€” left mein right daalo aur right mein left.

return root;
â¡ï¸ Final root node return karo jisme inverted left aur right subtree honge.

ğŸ§  Time Complexity:
â¡ï¸ O(n) â€” Har node ko ek baar visit karte hain.

ğŸ”— If any need please ask me: https://www.linkedin.com/in/saurabh884095/
